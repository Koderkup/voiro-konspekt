cp node_modules/pdfjs-dist/build/pdf.worker.min.js public/pdf.worker.min.js


  // const openPDFDatabase = async (): Promise<IDBDatabase> => {
  //   return new Promise((resolve, reject) => {
  //     const request = indexedDB.open("PDFStorage", 1);
  //     request.onupgradeneeded = () => {
  //       const db = request.result;
  //       if (!db.objectStoreNames.contains("files")) {
  //         db.createObjectStore("files");
  //       }
  //     };
  //     request.onsuccess = () => resolve(request.result);
  //     request.onerror = () => reject(request.error);
  //   });
  // };

  // const savePDFToDB = async (key: string, bytes: Uint8Array) => {
  //   const db = await openPDFDatabase();
  //   const tx = db.transaction("files", "readwrite");
  //   tx.objectStore("files").put(bytes, key);
  //   return new Promise<void>((resolve, reject) => {
  //     tx.oncomplete = () => resolve();
  //     tx.onerror = () => reject(tx.error);
  //   });
  // };

  // const loadPDFFromDB = async (key: string): Promise<Uint8Array | null> => {
  //   const db = await openPDFDatabase();
  //   const tx = db.transaction("files", "readonly");
  //   const request = tx.objectStore("files").get(key);
  //   return new Promise((resolve, reject) => {
  //     request.onsuccess = () => {
  //       const result = request.result;
  //       if (result instanceof Uint8Array) return resolve(result);
  //       if (result instanceof ArrayBuffer)
  //         return resolve(new Uint8Array(result));
  //       if (result instanceof Blob) {
  //         result.arrayBuffer().then((buf) => resolve(new Uint8Array(buf)));
  //       } else resolve(null);
  //     };
  //     request.onerror = () => reject(request.error);
  //   });
  // };

  // const wrapText = (
  //   ctx: CanvasRenderingContext2D,
  //   text: string,
  //   x: number,
  //   y: number,
  //   maxWidth: number,
  //   lineHeight: number
  // ) => {
  //   const words = text.split(" ");
  //   let line = "";
  //   for (let n = 0; n < words.length; n++) {
  //     const testLine = line + words[n] + " ";
  //     const metrics = ctx.measureText(testLine);
  //     const testWidth = metrics.width;
  //     if (testWidth > maxWidth && n > 0) {
  //       ctx.fillText(line, x, y);
  //       line = words[n] + " ";
  //       y += lineHeight;
  //     } else {
  //       line = testLine;
  //     }
  //   }
  //   ctx.fillText(line, x, y);
  // };

// const renderPage = async (n: number) => {
  //   if (isRendering.current || !pdfDoc) return;
  //   isRendering.current = true;

  //   const page = await pdfDoc.getPage(n);
  //   const viewport = page.getViewport({ scale });
  //   const canvas = canvasRef.current!;
  //   const ctx = canvas.getContext("2d")!;
  //   canvas.width = viewport.width;
  //   canvas.height = viewport.height;

  //   await page.render({ canvasContext: ctx, viewport }).promise;

  //   ctx.font = "16px sans-serif";
  //   ctx.fillStyle = "black";
  //   ctx.textBaseline = "top";

  //   textItems
  //     .filter((t) => t.page === n)
  //     .forEach((item) => {
  //       wrapText(ctx, item.text, item.canvasX, item.canvasY, 300, 20);
  //     });

  //   setPageNum(n);
  //   isRendering.current = false;
  // };

  // const loadPDF = () => {
  //   const file = fileRef.current?.files?.[0];
  //   if (!file) return alert("–í—ã–±–µ—Ä–∏—Ç–µ PDF-—Ñ–∞–π–ª");

  //   const reader = new FileReader();
  //   reader.onload = async () => {
  //     const bytes = new Uint8Array(reader.result as ArrayBuffer);
  //     await savePDFToDB("pdfRaw", bytes);

  //     const doc = await pdfjsLib.getDocument({ data: bytes }).promise;
  //     setPdfDoc(doc);
  //     setPageCount(doc.numPages);
  //     renderPage(1);
  //   };
  //   reader.readAsArrayBuffer(file);
  // };

  // const handleCanvasClick = (e: React.MouseEvent) => {
  //   const canvas = canvasRef.current!;
  //   const rect = canvas.getBoundingClientRect();
  //   const canvasX = ((e.clientX - rect.left) * canvas.width) / rect.width;
  //   const canvasY = ((e.clientY - rect.top) * canvas.height) / rect.height;

  //   const text = textRef.current?.value.trim();
  //   if (!text) return;

  //   const newItem = { text, page: pageNum, canvasX, canvasY };
  //   const newItems = [...textItems, newItem];
  //   setTextItems(newItems);
  //   localStorage.setItem("textItems", JSON.stringify(newItems));
  //   renderPage(pageNum);
  // };

  // const savePdf = async () => {
  //   const pdfBytes = await loadPDFFromDB("pdfRaw");
  //   if (!pdfBytes || textItems.length === 0)
  //     return alert("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è");

  //   const doc = await PDFDocument.load(pdfBytes);
  //   doc.registerFontkit(fontkit);

  //   const fontBytes = await fetch(
  //     "https://cdn.jsdelivr.net/npm/dejavu-fonts-ttf@2.37/ttf/DejaVuSans.ttf"
  //   ).then((r) => r.arrayBuffer());
  //   const font = await doc.embedFont(fontBytes);
  //   const pages = doc.getPages();

  //   for (const item of textItems) {
  //     const page = pages[item.page - 1];
  //     const { width, height } = page.getSize();
  //     const scaleX = width / canvasRef.current!.width;
  //     const scaleY = height / canvasRef.current!.height;

  //     let pdfX = item.canvasX * scaleX;
  //     let pdfY = height - item.canvasY * scaleY;

  //     const maxWidth = 300;
  //     const lineHeight = 16;
  //     const words = item.text.split(" ");
  //     let line = "";

  //     for (let i = 0; i < words.length; i++) {
  //       const testLine = line + words[i] + " ";
  //       const testWidth = font.widthOfTextAtSize(testLine, 16);
  //       if (testWidth > maxWidth && i > 0) {
  //         page.drawText(line.trim(), {
  //           x: pdfX,
  //           y: pdfY,
  //           size: 11,
  //           font,
  //           color: rgb(0, 0, 0),
  //         });
  //         line = words[i] + " ";
  //         pdfY -= lineHeight;
  //       } else {
  //         line = testLine;
  //       }
  //     }

  //     if (line.trim()) {
  //       page.drawText(line.trim(), {
  //         x: pdfX,
  //         y: pdfY,
  //         size: 11,
  //         font,
  //         color: rgb(0, 0, 0),
  //       });
  //     }
  //   }

  //   const safeBuffer = new ArrayBuffer(pdfBytes.length);
  //   const safeBytes = new Uint8Array(safeBuffer);
  //   safeBytes.set(pdfBytes);

  //   const blob = new Blob([safeBytes], { type: "application/pdf" });
  //   const link = document.createElement("a");
  //   link.href = URL.createObjectURL(blob);
  //   link.download = "annotated.pdf";
  //   link.click();
  //   setTimeout(() => URL.revokeObjectURL(link.href), 1500);
  // };


***********************************PdfEditor******************************************************************
// "use client";
// import React, { useRef, useEffect, useState } from "react";
// import * as pdfjsLib from "pdfjs-dist";
// import { Button, Flex, Input } from "@chakra-ui/react";
// import pdfUtils from "../../utils/pdfUtils";

// pdfjsLib.GlobalWorkerOptions.workerSrc =
//   "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.6.172/pdf.worker.min.js";

// const PdfEditor = () => {
//   const canvasRef = useRef<HTMLCanvasElement>(null);
//   const fileRef = useRef<HTMLInputElement>(null);
//   const textRef = useRef<HTMLTextAreaElement>(null);
//   const [pdfDoc, setPdfDoc] = useState<any>(null);
//   const [pageNum, setPageNum] = useState(1);
//   const [pageCount, setPageCount] = useState(0);
//   const [textItems, setTextItems] = useState<any[]>([]);
//   const [scale, setScale] = useState(1.2);
//   const isRendering = useRef(false);
//   const initialRenderDone = useRef(false);

//   const {
//     openPDFDatabase,
//     savePDFToDB,
//     loadPDFFromDB,
//     wrapText,
//     renderPage,
//     loadPDF,
//     handleCanvasClick,
//     savePdf,
//   } = pdfUtils;

//   useEffect(() => {
//     const loadInitialData = async () => {
//       const pdfBytes = await loadPDFFromDB("pdfRaw");
//       if (!pdfBytes) return;

//       const doc = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
//       setPdfDoc(doc);
//       setPageCount(doc.numPages);

//       const savedText = localStorage.getItem("textItems");
//       if (savedText) {
//         const parsed = JSON.parse(savedText);
//         setTextItems(parsed);
//       }

//       const savedPageNum = localStorage.getItem("lastPageNum");
//       if (savedPageNum) {
//         setPageNum(parseInt(savedPageNum));
//       }
//     };

//     loadInitialData();
//   }, []);

//   useEffect(() => {
//     if (
//       pdfDoc &&
//       canvasRef.current &&
//       !initialRenderDone.current &&
//       textItems.length >= 0
//     ) {
//       initialRenderDone.current = true;
//       renderPage(pageNum);
//     }
//   }, [pdfDoc, textItems]);

//   return (
//     <Flex>
//       <Input
//         ref={fileRef}
//         type="file"
//         accept="application/pdf"
//         width={"fit-content"}
//       />
//       <Button colorPalette="cyan" variant="surface" onClick={loadPDF}>
//         üìÇ –ü–æ–∫–∞–∑–∞—Ç—å PDF
//       </Button>
//       <canvas
//         ref={canvasRef}
//         onClick={handleCanvasClick}
//         style={{
//           border: "1px solid #ccc",
//           margin: "1rem auto",
//           display: "block",
//           cursor: "crosshair",
//         }}
//       />
//       <div>
//         <Button
//           variant="outline"
//           onClick={() => {
//             const newPage = Math.max(1, pageNum - 1);
//             setPageNum(newPage);
//             localStorage.setItem("lastPageNum", String(newPage));
//           }}
//         >
//           ‚¨Ö
//         </Button>
//         <Button
//           variant="outline"
//           onClick={() => {
//             const newPage = Math.min(pageCount, pageNum + 1);
//             setPageNum(newPage);
//             localStorage.setItem("lastPageNum", String(newPage));
//           }}
//         >
//           ‚û°
//         </Button>

//         <Button
//           variant="outline"
//           onClick={() => setScale((s) => Math.min(s + 0.2, 3))}
//         >
//           üîç+
//         </Button>
//         <Button
//           variant="outline"
//           onClick={() => setScale((s) => Math.max(s - 0.2, 0.4))}
//         >
//           üîé‚Äì
//         </Button>
//         <Button variant="surface" colorPalette="cyan" onClick={savePdf}>
//           üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å PDF
//         </Button>
//       </div>

//       <div>
//         <textarea
//           ref={textRef}
//           rows={3}
//           cols={30}
//           placeholder="‚úèÔ∏è –í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç‚Ä¶"
//         />
//       </div>

//       <div>
//         <p>
//           –°—Ç—Ä–∞–Ω–∏—Ü–∞: {pageNum} / {pageCount}
//         </p>
//       </div>
//     </Flex>
//   );
// };

// export default PdfEditor;



// useEffect(() => {
  //   const loadInitialData = async () => {
  //     if (!uid || !fileRef.current) return;
  //     const pdfBytes = await loadPDFFromDB(key);
  //     if (!pdfBytes) return;

  //     const doc = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
  //     setPdfDoc(doc);
  //     setPageCount(doc.numPages);

  //     const savedText = localStorage.getItem(getKey("textItems"));
  //     if (savedText) {
  //       const parsed = JSON.parse(savedText);
  //       setTextItems(parsed);
  //     }

  //     const savedPageNum = localStorage.getItem(getKey("lastPageNum"));
  //     if (savedPageNum) {
  //       setPageNum(parseInt(savedPageNum));
  //     }
  //   };

  //   loadInitialData();
  // }, []);




  useEffect(() => {
    if (
      pdfDoc &&
      canvasRef.current &&
      !initialRenderDone.current &&
      textItems.length >= 0
    ) {
      initialRenderDone.current = true;
      renderPageWithParams(pageNum);
    }
  }, [pdfDoc, textItems]);

  useEffect(() => {
    if (pdfDoc && canvasRef.current && initialRenderDone.current) {
      renderPageWithParams(pageNum);
    }
  }, [pageNum, scale]);

  useEffect(() => {
    if (pdfDoc && canvasRef.current) {
      renderPageWithParams(pageNum);
    }
  }, [textItems]);



const wrapText = (
  ctx: CanvasRenderingContext2D,
  text: string,
  x: number,
  y: number,
  maxWidth: number,
  lineHeight: number
) => {
  if (typeof window !== "undefined") {
    const words = text.split(" ");
    let line = "";
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + " ";
      const metrics = ctx.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        ctx.fillText(line, x, y);
        line = words[n] + " ";
        y += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line, x, y);
  } else {
    throw new Error("Window is not defined");
  }
};

export const renderPage = async (
  pageNum: number,
  pdfDoc: any,
  canvasRef: React.RefObject<HTMLCanvasElement>,
  textItems: any[],
  scale: number,
  setPageNum: (n: number) => void,
  wrapTextFn: typeof wrapText,
  isRenderingRef: React.MutableRefObject<boolean>
) => {
  if (isRenderingRef.current || !pdfDoc) return;
  isRenderingRef.current = true;

  const page = await pdfDoc.getPage(pageNum);
  const viewport = page.getViewport({ scale });
  const canvas = canvasRef.current!;
  const ctx = canvas.getContext("2d")!;
  canvas.width = viewport.width;
  canvas.height = viewport.height;

  await page.render({ canvasContext: ctx, viewport }).promise;

  ctx.font = "16px sans-serif";
  ctx.fillStyle = "black";
  ctx.textBaseline = "top";

  textItems
    .filter((t) => t.page === pageNum)
    .forEach((item) => {
      const absX = item.relativeX * canvas.width;
      const absY = item.relativeY * canvas.height;
      wrapTextFn(ctx, item.text, absX, absY, 300, 20);
    });

  setPageNum(pageNum);
  isRenderingRef.current = false;
};



// import { TextItem } from "../types/types";
// import { useEffect, useRef } from "react";

// export function useCanvasDrag({
//   canvasRef,
//   textItems,
//   pageNum,
//   ctx,
//   onUpdate,
//   onRender,
// }: {
//   canvasRef: React.RefObject<HTMLCanvasElement>;
//   textItems: TextItem[];
//   pageNum: number;
//   ctx: CanvasRenderingContext2D;
//   onUpdate: (updatedItems: TextItem[]) => void;
//   onRender: () => void; 
// }) {
//   const draggingItemRef = useRef<TextItem | null>(null);
//   const offsetRef = useRef({ x: 0, y: 0 });
//   const scheduledRef = useRef(false);
//   const pendingItemsRef = useRef<TextItem[]>([]);

//   useEffect(() => {
//     const canvas = canvasRef.current;
//     if (!canvas || !ctx) return;

//     const getCoords = (clientX: number, clientY: number) => {
//       const rect = canvas.getBoundingClientRect();
//       return {
//         x: ((clientX - rect.left) * canvas.width) / rect.width,
//         y: ((clientY - rect.top) * canvas.height) / rect.height,
//       };
//     };

//     const checkHit = (x: number, y: number) => {
//       for (const item of textItems) {
//         if (item.page !== pageNum) continue;
//         const metrics = ctx.measureText(item.text);
//         const w = metrics.width;
//         const h = 20;
//         const itemX = item.relativeX * canvas.width;
//         const itemY = item.relativeY * canvas.height;

//         if (x >= itemX && x <= itemX + w && y >= itemY && y <= itemY + h) {
//           draggingItemRef.current = item;
//           offsetRef.current = {
//             x: x - itemX,
//             y: y - itemY,
//           };
//           if (navigator.vibrate) navigator.vibrate(50);
//           break;
//         }
//       }
//     };

//     const scheduleUpdate = () => {
//       if (!scheduledRef.current) {
//         scheduledRef.current = true;
//         requestAnimationFrame(() => {
//           onUpdate([...pendingItemsRef.current]);
//           scheduledRef.current = false;
//         });
//       }
//     };

//     const handleStart = (x: number, y: number) => checkHit(x, y);

//     const handleMove = (x: number, y: number) => {
//       const item = draggingItemRef.current;
//       if (!item) return;
//       item.relativeX = (x - offsetRef.current.x) / canvas.width;
//       item.relativeY = (y - offsetRef.current.y) / canvas.height;
//       pendingItemsRef.current = [...textItems];
//       scheduleUpdate();
//     };

//     const handleEnd = () => {
//       draggingItemRef.current = null;
//       onUpdate([...textItems]); // —Ñ–∏–Ω–∞–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
//       onRender(); // –æ—Ç—Ä–∏—Å–æ–≤–∫–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
//     };

//     // Touch and Mouse handlers
//     const touchStart = (e: TouchEvent) => {
//       const { x, y } = getCoords(e.touches[0].clientX, e.touches[0].clientY);
//       handleStart(x, y);
//     };

//     const touchMove = (e: TouchEvent) => {
//       if (!draggingItemRef.current) return;
//       e.preventDefault();
//       const { x, y } = getCoords(e.touches[0].clientX, e.touches[0].clientY);
//       handleMove(x, y);
//     };

//     const mouseDown = (e: MouseEvent) => {
//       const { x, y } = getCoords(e.clientX, e.clientY);
//       handleStart(x, y);
//     };

//     const mouseMove = (e: MouseEvent) => {
//       if (!draggingItemRef.current) return;
//       const { x, y } = getCoords(e.clientX, e.clientY);
//       handleMove(x, y);
//     };

//     const removeListeners = () => {
//       canvas.removeEventListener("touchstart", touchStart);
//       canvas.removeEventListener("touchmove", touchMove);
//       canvas.removeEventListener("touchend", handleEnd);
//       canvas.removeEventListener("mousedown", mouseDown);
//       canvas.removeEventListener("mousemove", mouseMove);
//       canvas.removeEventListener("mouseup", handleEnd);
//     };

//     canvas.addEventListener("touchstart", touchStart);
//     canvas.addEventListener("touchmove", touchMove, { passive: false });
//     canvas.addEventListener("touchend", handleEnd);
//     canvas.addEventListener("mousedown", mouseDown);
//     canvas.addEventListener("mousemove", mouseMove);
//     canvas.addEventListener("mouseup", handleEnd);

//     return removeListeners;
//   }, [canvasRef, textItems, pageNum, ctx, onUpdate, onRender]);
// }




// export const handleCanvasClick = (
//   e: React.MouseEvent,
//   key: string,
//   canvasRef: React.RefObject<HTMLCanvasElement>,
//   textRef: React.RefObject<HTMLTextAreaElement>,
//   pageNum: number,
//   textItems: any[],
//   setTextItems: (items: any[]) => void,
//   renderPageFn: (updatedItems: any[]) => void
// ) => {
//   const canvas = canvasRef.current!;
//   const rect = canvas.getBoundingClientRect();
//   const canvasX = ((e.clientX - rect.left) * canvas.width) / rect.width;
//   const canvasY = ((e.clientY - rect.top) * canvas.height) / rect.height;

//   const relativeX = canvasX / canvas.width;
//   const relativeY = canvasY / canvas.height;

//   const text = textRef.current?.value.trim();
//   if (!text) return;

//   const newItem = { text, page: pageNum, relativeX, relativeY };
//   const newItems = [...textItems, newItem];
//   setTextItems(newItems);
//   localStorage.setItem(key, JSON.stringify(newItems));

//   renderPageFn(newItems);
// };




useEffect drag-n-drop

 useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas || !pdfDoc) return;

    let draggingItem: TextItem | null = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;

    const getCoords = (clientX: number, clientY: number) => {
      const rect = canvas.getBoundingClientRect();
      return {
        x: ((clientX - rect.left) * canvas.width) / rect.width,
        y: ((clientY - rect.top) * canvas.height) / rect.height,
      };
    };

    const mouseDown = (e: MouseEvent) => {
      const { x, y } = getCoords(e.clientX, e.clientY);
      for (const item of textItems) {
        if (item.page !== pageNum) continue;

        const ctx = canvas.getContext("2d");
        if (!ctx) continue;

        const metrics = ctx.measureText(item.text);
        const w = metrics.width;
        const h = 20;

        const itemX = item.relativeX * canvas.width;
        const itemY = item.relativeY * canvas.height;

        if (x >= itemX && x <= itemX + w && y >= itemY && y <= itemY + h) {
          draggingItem = item;
          dragOffsetX = x - itemX;
          dragOffsetY = y - itemY;
          if (navigator.vibrate) navigator.vibrate(50);
          break;
        }
      }
    };

    const mouseMove = (e: MouseEvent) => {
      if (!draggingItem) return;
      const { x, y } = getCoords(e.clientX, e.clientY);
      draggingItem.relativeX = (x - dragOffsetX) / canvas.width;
      draggingItem.relativeY = (y - dragOffsetY) / canvas.height;
      localStorage.setItem(textKey, JSON.stringify(textItems));
    };

    const mouseUp = () => {
      if (draggingItem) {
        draggingItem = null;
        renderPageWithParams(pageNum);
        setTextItems([...textItems]); // –æ–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
      }
    };

    const touchStart = (e: TouchEvent) => {
      const touch = e.touches[0];
      const { x, y } = getCoords(touch.clientX, touch.clientY);
      for (const item of textItems) {
        if (item.page !== pageNum) continue;

        const ctx = canvas.getContext("2d");
        if (!ctx) continue;

        const metrics = ctx.measureText(item.text);
        const w = metrics.width;
        const h = 20;

        const itemX = item.relativeX * canvas.width;
        const itemY = item.relativeY * canvas.height;

        if (x >= itemX && x <= itemX + w && y >= itemY && y <= itemY + h) {
          draggingItem = item;
          dragOffsetX = x - itemX;
          dragOffsetY = y - itemY;
          if (navigator.vibrate) navigator.vibrate(50);
          break;
        }
      }
    };

    const touchMove = (e: TouchEvent) => {
      if (!draggingItem) return;
      e.preventDefault();
      const touch = e.touches[0];
      const { x, y } = getCoords(touch.clientX, touch.clientY);
      draggingItem.relativeX = (x - dragOffsetX) / canvas.width;
      draggingItem.relativeY = (y - dragOffsetY) / canvas.height;
      localStorage.setItem(textKey, JSON.stringify(textItems));
    };

    const touchEnd = () => {
      if (draggingItem) {
        draggingItem = null;
        renderPageWithParams(pageNum);
        setTextItems([...textItems]);
      }
    };

    canvas.addEventListener("mousedown", mouseDown);
    canvas.addEventListener("mousemove", mouseMove);
    canvas.addEventListener("mouseup", mouseUp);
    canvas.addEventListener("touchstart", touchStart);
    canvas.addEventListener("touchmove", touchMove, { passive: false });
    canvas.addEventListener("touchend", touchEnd);

    return () => {
      canvas.removeEventListener("mousedown", mouseDown);
      canvas.removeEventListener("mousemove", mouseMove);
      canvas.removeEventListener("mouseup", mouseUp);
      canvas.removeEventListener("touchstart", touchStart);
      canvas.removeEventListener("touchmove", touchMove);
      canvas.removeEventListener("touchend", touchEnd);
    };
  }, [canvasRef, textItems, pageNum, renderPageWithParams, textKey]);




  // const handleContextMenu = useCallback(
  //   (e: MouseEvent) => {
  //     e.preventDefault();
  //     const canvas = canvasRef.current;
  //     if (!canvas) return;

  //     const rect = canvas.getBoundingClientRect();
  //     const canvasX = Math.round(
  //       ((e.clientX - rect.left) * canvas.width) / rect.width
  //     );
  //     const canvasY = Math.round(
  //       ((e.clientY - rect.top) * canvas.height) / rect.height
  //     );

  //     setTextItems((prev) => {
  //       const indexToRemove = prev.findIndex((item) => {
  //         const absX = item.relativeX * canvas.width;
  //         const absY = item.relativeY * canvas.height;
  //         return (
  //           Math.abs(absX - canvasX) < 10 &&
  //           Math.abs(absY - canvasY) < 10 &&
  //           item.page === pageNum
  //         );
  //       });

  //       if (indexToRemove !== -1) {
  //         const updated = [...prev];
  //         console.log(`–£–¥–∞–ª—è–µ–º —Ç–µ–∫—Å—Ç: "${updated[indexToRemove].text}"`);
  //         updated.splice(indexToRemove, 1);
  //         localStorage.setItem(textKey, JSON.stringify(updated));
  //         return updated;
  //       } else {
  //         console.log("–¢–µ–∫—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.");
  //         return prev;
  //       }
  //     });
  //   },
  //   [pageNum, textItems, textKey]
  // );

  // useEffect(() => {
  //   const canvas = canvasRef.current;
  //   if (!canvas) return;

  //   canvas.addEventListener("contextmenu", handleContextMenu);
  //   return () => {
  //     canvas.removeEventListener("contextmenu", handleContextMenu);
  //   };
  // }, [handleContextMenu]);







  export const savePdf = async (
  canvasRef: React.RefObject<HTMLCanvasElement>,
  key: string,
  loadPDFFromDB: (key: string) => Promise<Uint8Array | null>,
  textItems: any[]
) => {
  const pdfBytes = await loadPDFFromDB(key);
  if (!pdfBytes || textItems.length === 0)
    return { success: false, message: "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è" };
  const doc = await PDFDocument.load(pdfBytes);
  doc.registerFontkit(fontkit);

  const fontBytes = await fetch(
    "https://cdn.jsdelivr.net/npm/dejavu-fonts-ttf@2.37/ttf/DejaVuSans.ttf"
  ).then((r) => r.arrayBuffer());
  const font = await doc.embedFont(fontBytes);
  const pages = doc.getPages();

  for (const item of textItems) {
    const page = pages[item.page - 1];
    const { width, height } = page.getSize();
    let pdfX = item.relativeX * width;
    let pdfY = height - item.relativeY * height;

    const maxWidth = 300;
    const lineHeight = 16;
    const words = item.text.split(" ");
    let line = "";

    for (let i = 0; i < words.length; i++) {
      const testLine = line + words[i] + " ";
      const testWidth = font.widthOfTextAtSize(testLine, 16);
      if (testWidth > maxWidth && i > 0) {
        page.drawText(line.trim(), {
          x: pdfX,
          y: pdfY,
          size: 11,
          font,
          color: rgb(0, 0, 0),
        });
        line = words[i] + " ";
        pdfY -= lineHeight;
      } else {
        line = testLine;
      }
    }

    if (line.trim()) {
      page.drawText(line.trim(), {
        x: pdfX,
        y: pdfY,
        size: 11,
        font,
        color: rgb(0, 0, 0),
      });
    }
  }
  const modifiedPdfBytes = await doc.save();
  const blob = new Blob([new Uint8Array(modifiedPdfBytes)], {
    type: "application/pdf",
  });
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = "konspekt.pdf";
  link.click();
  setTimeout(() => URL.revokeObjectURL(link.href), 1500);
  return { success: true, message: "–§–∞–π–ª —Å–æ—Ö—Ä–∞–Ω–µ–Ω" };
};




// export const renderPage = async (
//   pageNum: number,
//   pdfDoc: any,
//   canvasRef: React.RefObject<HTMLCanvasElement>,
//   textItems: any[],
//   scale: number,
//   setPageNum: (n: number) => void,
//   wrapTextFn: typeof wrapText,
//   isRenderingRef: React.MutableRefObject<boolean>,
//   fontValue: number = 16,
//   lineValue: number = 300
// ) => {
//   if (isRenderingRef.current || !pdfDoc) return;
//   isRenderingRef.current = true;

//   const page = await pdfDoc.getPage(pageNum);
//   const viewport = page.getViewport({ scale });
//   const canvas = canvasRef.current;
//   const ctx = canvas?.getContext("2d");
//   if (!canvas || !ctx) {
//     isRenderingRef.current = false;
//     return;
//   }

//   canvas.width = viewport.width;
//   canvas.height = viewport.height;

//   await page.render({ canvasContext: ctx, viewport }).promise;
//   const lineHeight = fontValue + 4;

//   textItems
//     .filter((t) => t.page === pageNum)
//     .forEach((item) => {
//       const absX = item.relativeX * canvas.width;
//       const absY = item.relativeY * canvas.height;

//       const font = item.fontSize ?? fontValue;
//       const line = item.lineWidth ?? lineValue;
//       const lineHeight = font + 4;

//       ctx.font = `${font}px sans-serif`;
//       ctx.fillStyle = "black";
//       ctx.textBaseline = "top";

//       wrapTextFn(ctx, item.text, absX, absY, line, lineHeight);
//     });

//   setPageNum(pageNum);
//   isRenderingRef.current = false;
// };


export const renderPage = async (
  pageNum: number,
  pdfDoc: any,
  canvasRef: React.RefObject<HTMLCanvasElement>,
  textItems: any[],
  scale: number,
  setPageNum: (n: number) => void,
  wrapTextFn: typeof wrapText,
  isRenderingRef: React.MutableRefObject<boolean>,
  fontValue: number = 16,
  lineValue: number = 300
) => {
  if (isRenderingRef.current || !pdfDoc) return;
  isRenderingRef.current = true;

  const page = await pdfDoc.getPage(pageNum);

  const devicePixelRatio = window.devicePixelRatio || 1;
  const viewport = page.getViewport({ scale: scale * devicePixelRatio });

  const canvas = canvasRef.current;
  const ctx = canvas?.getContext("2d");
  if (!canvas || !ctx) {
    isRenderingRef.current = false;
    return;
  }

  // –§–∏–∑–∏—á–µ—Å–∫–∏–π —Ä–∞–∑–º–µ—Ä (–¥–ª—è —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞)
  canvas.width = viewport.width;
  canvas.height = viewport.height;

  // CSS —Ä–∞–∑–º–µ—Ä (–Ω–∞ —ç–∫—Ä–∞–Ω–µ)
  canvas.style.width = `${viewport.width / devicePixelRatio}px`;
  canvas.style.height = `${viewport.height / devicePixelRatio}px`;

  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";

  await page.render({ canvasContext: ctx, viewport }).promise;

  // –†–∏—Å—É–µ–º —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
  textItems
    .filter((t) => t.page === pageNum)
    .forEach((item) => {
      const absX = item.relativeX * canvas.width;
      const absY = item.relativeY * canvas.height;
      const font = item.fontSize ?? fontValue;
      const line = item.lineWidth ?? lineValue;
      const lineHeight = font + 4;

      ctx.font = `${font}px sans-serif`;
      ctx.fillStyle = "black";
      ctx.textBaseline = "top";

      wrapTextFn(ctx, item.text, absX, absY, line, lineHeight);
    });

  setPageNum(pageNum);
  isRenderingRef.current = false;
};
