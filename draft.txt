cp node_modules/pdfjs-dist/build/pdf.worker.min.js public/pdf.worker.min.js


  // const openPDFDatabase = async (): Promise<IDBDatabase> => {
  //   return new Promise((resolve, reject) => {
  //     const request = indexedDB.open("PDFStorage", 1);
  //     request.onupgradeneeded = () => {
  //       const db = request.result;
  //       if (!db.objectStoreNames.contains("files")) {
  //         db.createObjectStore("files");
  //       }
  //     };
  //     request.onsuccess = () => resolve(request.result);
  //     request.onerror = () => reject(request.error);
  //   });
  // };

  // const savePDFToDB = async (key: string, bytes: Uint8Array) => {
  //   const db = await openPDFDatabase();
  //   const tx = db.transaction("files", "readwrite");
  //   tx.objectStore("files").put(bytes, key);
  //   return new Promise<void>((resolve, reject) => {
  //     tx.oncomplete = () => resolve();
  //     tx.onerror = () => reject(tx.error);
  //   });
  // };

  // const loadPDFFromDB = async (key: string): Promise<Uint8Array | null> => {
  //   const db = await openPDFDatabase();
  //   const tx = db.transaction("files", "readonly");
  //   const request = tx.objectStore("files").get(key);
  //   return new Promise((resolve, reject) => {
  //     request.onsuccess = () => {
  //       const result = request.result;
  //       if (result instanceof Uint8Array) return resolve(result);
  //       if (result instanceof ArrayBuffer)
  //         return resolve(new Uint8Array(result));
  //       if (result instanceof Blob) {
  //         result.arrayBuffer().then((buf) => resolve(new Uint8Array(buf)));
  //       } else resolve(null);
  //     };
  //     request.onerror = () => reject(request.error);
  //   });
  // };

  // const wrapText = (
  //   ctx: CanvasRenderingContext2D,
  //   text: string,
  //   x: number,
  //   y: number,
  //   maxWidth: number,
  //   lineHeight: number
  // ) => {
  //   const words = text.split(" ");
  //   let line = "";
  //   for (let n = 0; n < words.length; n++) {
  //     const testLine = line + words[n] + " ";
  //     const metrics = ctx.measureText(testLine);
  //     const testWidth = metrics.width;
  //     if (testWidth > maxWidth && n > 0) {
  //       ctx.fillText(line, x, y);
  //       line = words[n] + " ";
  //       y += lineHeight;
  //     } else {
  //       line = testLine;
  //     }
  //   }
  //   ctx.fillText(line, x, y);
  // };

// const renderPage = async (n: number) => {
  //   if (isRendering.current || !pdfDoc) return;
  //   isRendering.current = true;

  //   const page = await pdfDoc.getPage(n);
  //   const viewport = page.getViewport({ scale });
  //   const canvas = canvasRef.current!;
  //   const ctx = canvas.getContext("2d")!;
  //   canvas.width = viewport.width;
  //   canvas.height = viewport.height;

  //   await page.render({ canvasContext: ctx, viewport }).promise;

  //   ctx.font = "16px sans-serif";
  //   ctx.fillStyle = "black";
  //   ctx.textBaseline = "top";

  //   textItems
  //     .filter((t) => t.page === n)
  //     .forEach((item) => {
  //       wrapText(ctx, item.text, item.canvasX, item.canvasY, 300, 20);
  //     });

  //   setPageNum(n);
  //   isRendering.current = false;
  // };

  // const loadPDF = () => {
  //   const file = fileRef.current?.files?.[0];
  //   if (!file) return alert("–í—ã–±–µ—Ä–∏—Ç–µ PDF-—Ñ–∞–π–ª");

  //   const reader = new FileReader();
  //   reader.onload = async () => {
  //     const bytes = new Uint8Array(reader.result as ArrayBuffer);
  //     await savePDFToDB("pdfRaw", bytes);

  //     const doc = await pdfjsLib.getDocument({ data: bytes }).promise;
  //     setPdfDoc(doc);
  //     setPageCount(doc.numPages);
  //     renderPage(1);
  //   };
  //   reader.readAsArrayBuffer(file);
  // };

  // const handleCanvasClick = (e: React.MouseEvent) => {
  //   const canvas = canvasRef.current!;
  //   const rect = canvas.getBoundingClientRect();
  //   const canvasX = ((e.clientX - rect.left) * canvas.width) / rect.width;
  //   const canvasY = ((e.clientY - rect.top) * canvas.height) / rect.height;

  //   const text = textRef.current?.value.trim();
  //   if (!text) return;

  //   const newItem = { text, page: pageNum, canvasX, canvasY };
  //   const newItems = [...textItems, newItem];
  //   setTextItems(newItems);
  //   localStorage.setItem("textItems", JSON.stringify(newItems));
  //   renderPage(pageNum);
  // };

  // const savePdf = async () => {
  //   const pdfBytes = await loadPDFFromDB("pdfRaw");
  //   if (!pdfBytes || textItems.length === 0)
  //     return alert("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è");

  //   const doc = await PDFDocument.load(pdfBytes);
  //   doc.registerFontkit(fontkit);

  //   const fontBytes = await fetch(
  //     "https://cdn.jsdelivr.net/npm/dejavu-fonts-ttf@2.37/ttf/DejaVuSans.ttf"
  //   ).then((r) => r.arrayBuffer());
  //   const font = await doc.embedFont(fontBytes);
  //   const pages = doc.getPages();

  //   for (const item of textItems) {
  //     const page = pages[item.page - 1];
  //     const { width, height } = page.getSize();
  //     const scaleX = width / canvasRef.current!.width;
  //     const scaleY = height / canvasRef.current!.height;

  //     let pdfX = item.canvasX * scaleX;
  //     let pdfY = height - item.canvasY * scaleY;

  //     const maxWidth = 300;
  //     const lineHeight = 16;
  //     const words = item.text.split(" ");
  //     let line = "";

  //     for (let i = 0; i < words.length; i++) {
  //       const testLine = line + words[i] + " ";
  //       const testWidth = font.widthOfTextAtSize(testLine, 16);
  //       if (testWidth > maxWidth && i > 0) {
  //         page.drawText(line.trim(), {
  //           x: pdfX,
  //           y: pdfY,
  //           size: 11,
  //           font,
  //           color: rgb(0, 0, 0),
  //         });
  //         line = words[i] + " ";
  //         pdfY -= lineHeight;
  //       } else {
  //         line = testLine;
  //       }
  //     }

  //     if (line.trim()) {
  //       page.drawText(line.trim(), {
  //         x: pdfX,
  //         y: pdfY,
  //         size: 11,
  //         font,
  //         color: rgb(0, 0, 0),
  //       });
  //     }
  //   }

  //   const safeBuffer = new ArrayBuffer(pdfBytes.length);
  //   const safeBytes = new Uint8Array(safeBuffer);
  //   safeBytes.set(pdfBytes);

  //   const blob = new Blob([safeBytes], { type: "application/pdf" });
  //   const link = document.createElement("a");
  //   link.href = URL.createObjectURL(blob);
  //   link.download = "annotated.pdf";
  //   link.click();
  //   setTimeout(() => URL.revokeObjectURL(link.href), 1500);
  // };


***********************************PdfEditor******************************************************************
// "use client";
// import React, { useRef, useEffect, useState } from "react";
// import * as pdfjsLib from "pdfjs-dist";
// import { Button, Flex, Input } from "@chakra-ui/react";
// import pdfUtils from "../../utils/pdfUtils";

// pdfjsLib.GlobalWorkerOptions.workerSrc =
//   "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.6.172/pdf.worker.min.js";

// const PdfEditor = () => {
//   const canvasRef = useRef<HTMLCanvasElement>(null);
//   const fileRef = useRef<HTMLInputElement>(null);
//   const textRef = useRef<HTMLTextAreaElement>(null);
//   const [pdfDoc, setPdfDoc] = useState<any>(null);
//   const [pageNum, setPageNum] = useState(1);
//   const [pageCount, setPageCount] = useState(0);
//   const [textItems, setTextItems] = useState<any[]>([]);
//   const [scale, setScale] = useState(1.2);
//   const isRendering = useRef(false);
//   const initialRenderDone = useRef(false);

//   const {
//     openPDFDatabase,
//     savePDFToDB,
//     loadPDFFromDB,
//     wrapText,
//     renderPage,
//     loadPDF,
//     handleCanvasClick,
//     savePdf,
//   } = pdfUtils;

//   useEffect(() => {
//     const loadInitialData = async () => {
//       const pdfBytes = await loadPDFFromDB("pdfRaw");
//       if (!pdfBytes) return;

//       const doc = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
//       setPdfDoc(doc);
//       setPageCount(doc.numPages);

//       const savedText = localStorage.getItem("textItems");
//       if (savedText) {
//         const parsed = JSON.parse(savedText);
//         setTextItems(parsed);
//       }

//       const savedPageNum = localStorage.getItem("lastPageNum");
//       if (savedPageNum) {
//         setPageNum(parseInt(savedPageNum));
//       }
//     };

//     loadInitialData();
//   }, []);

//   useEffect(() => {
//     if (
//       pdfDoc &&
//       canvasRef.current &&
//       !initialRenderDone.current &&
//       textItems.length >= 0
//     ) {
//       initialRenderDone.current = true;
//       renderPage(pageNum);
//     }
//   }, [pdfDoc, textItems]);

//   return (
//     <Flex>
//       <Input
//         ref={fileRef}
//         type="file"
//         accept="application/pdf"
//         width={"fit-content"}
//       />
//       <Button colorPalette="cyan" variant="surface" onClick={loadPDF}>
//         üìÇ –ü–æ–∫–∞–∑–∞—Ç—å PDF
//       </Button>
//       <canvas
//         ref={canvasRef}
//         onClick={handleCanvasClick}
//         style={{
//           border: "1px solid #ccc",
//           margin: "1rem auto",
//           display: "block",
//           cursor: "crosshair",
//         }}
//       />
//       <div>
//         <Button
//           variant="outline"
//           onClick={() => {
//             const newPage = Math.max(1, pageNum - 1);
//             setPageNum(newPage);
//             localStorage.setItem("lastPageNum", String(newPage));
//           }}
//         >
//           ‚¨Ö
//         </Button>
//         <Button
//           variant="outline"
//           onClick={() => {
//             const newPage = Math.min(pageCount, pageNum + 1);
//             setPageNum(newPage);
//             localStorage.setItem("lastPageNum", String(newPage));
//           }}
//         >
//           ‚û°
//         </Button>

//         <Button
//           variant="outline"
//           onClick={() => setScale((s) => Math.min(s + 0.2, 3))}
//         >
//           üîç+
//         </Button>
//         <Button
//           variant="outline"
//           onClick={() => setScale((s) => Math.max(s - 0.2, 0.4))}
//         >
//           üîé‚Äì
//         </Button>
//         <Button variant="surface" colorPalette="cyan" onClick={savePdf}>
//           üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å PDF
//         </Button>
//       </div>

//       <div>
//         <textarea
//           ref={textRef}
//           rows={3}
//           cols={30}
//           placeholder="‚úèÔ∏è –í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç‚Ä¶"
//         />
//       </div>

//       <div>
//         <p>
//           –°—Ç—Ä–∞–Ω–∏—Ü–∞: {pageNum} / {pageCount}
//         </p>
//       </div>
//     </Flex>
//   );
// };

// export default PdfEditor;



// useEffect(() => {
  //   const loadInitialData = async () => {
  //     if (!uid || !fileRef.current) return;
  //     const pdfBytes = await loadPDFFromDB(key);
  //     if (!pdfBytes) return;

  //     const doc = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
  //     setPdfDoc(doc);
  //     setPageCount(doc.numPages);

  //     const savedText = localStorage.getItem(getKey("textItems"));
  //     if (savedText) {
  //       const parsed = JSON.parse(savedText);
  //       setTextItems(parsed);
  //     }

  //     const savedPageNum = localStorage.getItem(getKey("lastPageNum"));
  //     if (savedPageNum) {
  //       setPageNum(parseInt(savedPageNum));
  //     }
  //   };

  //   loadInitialData();
  // }, []);




  useEffect(() => {
    if (
      pdfDoc &&
      canvasRef.current &&
      !initialRenderDone.current &&
      textItems.length >= 0
    ) {
      initialRenderDone.current = true;
      renderPageWithParams(pageNum);
    }
  }, [pdfDoc, textItems]);

  useEffect(() => {
    if (pdfDoc && canvasRef.current && initialRenderDone.current) {
      renderPageWithParams(pageNum);
    }
  }, [pageNum, scale]);

  useEffect(() => {
    if (pdfDoc && canvasRef.current) {
      renderPageWithParams(pageNum);
    }
  }, [textItems]);



const wrapText = (
  ctx: CanvasRenderingContext2D,
  text: string,
  x: number,
  y: number,
  maxWidth: number,
  lineHeight: number
) => {
  if (typeof window !== "undefined") {
    const words = text.split(" ");
    let line = "";
    for (let n = 0; n < words.length; n++) {
      const testLine = line + words[n] + " ";
      const metrics = ctx.measureText(testLine);
      const testWidth = metrics.width;
      if (testWidth > maxWidth && n > 0) {
        ctx.fillText(line, x, y);
        line = words[n] + " ";
        y += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line, x, y);
  } else {
    throw new Error("Window is not defined");
  }
};

export const renderPage = async (
  pageNum: number,
  pdfDoc: any,
  canvasRef: React.RefObject<HTMLCanvasElement>,
  textItems: any[],
  scale: number,
  setPageNum: (n: number) => void,
  wrapTextFn: typeof wrapText,
  isRenderingRef: React.MutableRefObject<boolean>
) => {
  if (isRenderingRef.current || !pdfDoc) return;
  isRenderingRef.current = true;

  const page = await pdfDoc.getPage(pageNum);
  const viewport = page.getViewport({ scale });
  const canvas = canvasRef.current!;
  const ctx = canvas.getContext("2d")!;
  canvas.width = viewport.width;
  canvas.height = viewport.height;

  await page.render({ canvasContext: ctx, viewport }).promise;

  ctx.font = "16px sans-serif";
  ctx.fillStyle = "black";
  ctx.textBaseline = "top";

  textItems
    .filter((t) => t.page === pageNum)
    .forEach((item) => {
      const absX = item.relativeX * canvas.width;
      const absY = item.relativeY * canvas.height;
      wrapTextFn(ctx, item.text, absX, absY, 300, 20);
    });

  setPageNum(pageNum);
  isRenderingRef.current = false;
};



// import { TextItem } from "../types/types";
// import { useEffect, useRef } from "react";

// export function useCanvasDrag({
//   canvasRef,
//   textItems,
//   pageNum,
//   ctx,
//   onUpdate,
//   onRender,
// }: {
//   canvasRef: React.RefObject<HTMLCanvasElement>;
//   textItems: TextItem[];
//   pageNum: number;
//   ctx: CanvasRenderingContext2D;
//   onUpdate: (updatedItems: TextItem[]) => void;
//   onRender: () => void; 
// }) {
//   const draggingItemRef = useRef<TextItem | null>(null);
//   const offsetRef = useRef({ x: 0, y: 0 });
//   const scheduledRef = useRef(false);
//   const pendingItemsRef = useRef<TextItem[]>([]);

//   useEffect(() => {
//     const canvas = canvasRef.current;
//     if (!canvas || !ctx) return;

//     const getCoords = (clientX: number, clientY: number) => {
//       const rect = canvas.getBoundingClientRect();
//       return {
//         x: ((clientX - rect.left) * canvas.width) / rect.width,
//         y: ((clientY - rect.top) * canvas.height) / rect.height,
//       };
//     };

//     const checkHit = (x: number, y: number) => {
//       for (const item of textItems) {
//         if (item.page !== pageNum) continue;
//         const metrics = ctx.measureText(item.text);
//         const w = metrics.width;
//         const h = 20;
//         const itemX = item.relativeX * canvas.width;
//         const itemY = item.relativeY * canvas.height;

//         if (x >= itemX && x <= itemX + w && y >= itemY && y <= itemY + h) {
//           draggingItemRef.current = item;
//           offsetRef.current = {
//             x: x - itemX,
//             y: y - itemY,
//           };
//           if (navigator.vibrate) navigator.vibrate(50);
//           break;
//         }
//       }
//     };

//     const scheduleUpdate = () => {
//       if (!scheduledRef.current) {
//         scheduledRef.current = true;
//         requestAnimationFrame(() => {
//           onUpdate([...pendingItemsRef.current]);
//           scheduledRef.current = false;
//         });
//       }
//     };

//     const handleStart = (x: number, y: number) => checkHit(x, y);

//     const handleMove = (x: number, y: number) => {
//       const item = draggingItemRef.current;
//       if (!item) return;
//       item.relativeX = (x - offsetRef.current.x) / canvas.width;
//       item.relativeY = (y - offsetRef.current.y) / canvas.height;
//       pendingItemsRef.current = [...textItems];
//       scheduleUpdate();
//     };

//     const handleEnd = () => {
//       draggingItemRef.current = null;
//       onUpdate([...textItems]); // —Ñ–∏–Ω–∞–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
//       onRender(); // –æ—Ç—Ä–∏—Å–æ–≤–∫–∞ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
//     };

//     // Touch and Mouse handlers
//     const touchStart = (e: TouchEvent) => {
//       const { x, y } = getCoords(e.touches[0].clientX, e.touches[0].clientY);
//       handleStart(x, y);
//     };

//     const touchMove = (e: TouchEvent) => {
//       if (!draggingItemRef.current) return;
//       e.preventDefault();
//       const { x, y } = getCoords(e.touches[0].clientX, e.touches[0].clientY);
//       handleMove(x, y);
//     };

//     const mouseDown = (e: MouseEvent) => {
//       const { x, y } = getCoords(e.clientX, e.clientY);
//       handleStart(x, y);
//     };

//     const mouseMove = (e: MouseEvent) => {
//       if (!draggingItemRef.current) return;
//       const { x, y } = getCoords(e.clientX, e.clientY);
//       handleMove(x, y);
//     };

//     const removeListeners = () => {
//       canvas.removeEventListener("touchstart", touchStart);
//       canvas.removeEventListener("touchmove", touchMove);
//       canvas.removeEventListener("touchend", handleEnd);
//       canvas.removeEventListener("mousedown", mouseDown);
//       canvas.removeEventListener("mousemove", mouseMove);
//       canvas.removeEventListener("mouseup", handleEnd);
//     };

//     canvas.addEventListener("touchstart", touchStart);
//     canvas.addEventListener("touchmove", touchMove, { passive: false });
//     canvas.addEventListener("touchend", handleEnd);
//     canvas.addEventListener("mousedown", mouseDown);
//     canvas.addEventListener("mousemove", mouseMove);
//     canvas.addEventListener("mouseup", handleEnd);

//     return removeListeners;
//   }, [canvasRef, textItems, pageNum, ctx, onUpdate, onRender]);
// }




// export const handleCanvasClick = (
//   e: React.MouseEvent,
//   key: string,
//   canvasRef: React.RefObject<HTMLCanvasElement>,
//   textRef: React.RefObject<HTMLTextAreaElement>,
//   pageNum: number,
//   textItems: any[],
//   setTextItems: (items: any[]) => void,
//   renderPageFn: (updatedItems: any[]) => void
// ) => {
//   const canvas = canvasRef.current!;
//   const rect = canvas.getBoundingClientRect();
//   const canvasX = ((e.clientX - rect.left) * canvas.width) / rect.width;
//   const canvasY = ((e.clientY - rect.top) * canvas.height) / rect.height;

//   const relativeX = canvasX / canvas.width;
//   const relativeY = canvasY / canvas.height;

//   const text = textRef.current?.value.trim();
//   if (!text) return;

//   const newItem = { text, page: pageNum, relativeX, relativeY };
//   const newItems = [...textItems, newItem];
//   setTextItems(newItems);
//   localStorage.setItem(key, JSON.stringify(newItems));

//   renderPageFn(newItems);
// };




useEffect drag-n-drop

 useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas || !pdfDoc) return;

    let draggingItem: TextItem | null = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;

    const getCoords = (clientX: number, clientY: number) => {
      const rect = canvas.getBoundingClientRect();
      return {
        x: ((clientX - rect.left) * canvas.width) / rect.width,
        y: ((clientY - rect.top) * canvas.height) / rect.height,
      };
    };

    const mouseDown = (e: MouseEvent) => {
      const { x, y } = getCoords(e.clientX, e.clientY);
      for (const item of textItems) {
        if (item.page !== pageNum) continue;

        const ctx = canvas.getContext("2d");
        if (!ctx) continue;

        const metrics = ctx.measureText(item.text);
        const w = metrics.width;
        const h = 20;

        const itemX = item.relativeX * canvas.width;
        const itemY = item.relativeY * canvas.height;

        if (x >= itemX && x <= itemX + w && y >= itemY && y <= itemY + h) {
          draggingItem = item;
          dragOffsetX = x - itemX;
          dragOffsetY = y - itemY;
          if (navigator.vibrate) navigator.vibrate(50);
          break;
        }
      }
    };

    const mouseMove = (e: MouseEvent) => {
      if (!draggingItem) return;
      const { x, y } = getCoords(e.clientX, e.clientY);
      draggingItem.relativeX = (x - dragOffsetX) / canvas.width;
      draggingItem.relativeY = (y - dragOffsetY) / canvas.height;
      localStorage.setItem(textKey, JSON.stringify(textItems));
    };

    const mouseUp = () => {
      if (draggingItem) {
        draggingItem = null;
        renderPageWithParams(pageNum);
        setTextItems([...textItems]); // –æ–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
      }
    };

    const touchStart = (e: TouchEvent) => {
      const touch = e.touches[0];
      const { x, y } = getCoords(touch.clientX, touch.clientY);
      for (const item of textItems) {
        if (item.page !== pageNum) continue;

        const ctx = canvas.getContext("2d");
        if (!ctx) continue;

        const metrics = ctx.measureText(item.text);
        const w = metrics.width;
        const h = 20;

        const itemX = item.relativeX * canvas.width;
        const itemY = item.relativeY * canvas.height;

        if (x >= itemX && x <= itemX + w && y >= itemY && y <= itemY + h) {
          draggingItem = item;
          dragOffsetX = x - itemX;
          dragOffsetY = y - itemY;
          if (navigator.vibrate) navigator.vibrate(50);
          break;
        }
      }
    };

    const touchMove = (e: TouchEvent) => {
      if (!draggingItem) return;
      e.preventDefault();
      const touch = e.touches[0];
      const { x, y } = getCoords(touch.clientX, touch.clientY);
      draggingItem.relativeX = (x - dragOffsetX) / canvas.width;
      draggingItem.relativeY = (y - dragOffsetY) / canvas.height;
      localStorage.setItem(textKey, JSON.stringify(textItems));
    };

    const touchEnd = () => {
      if (draggingItem) {
        draggingItem = null;
        renderPageWithParams(pageNum);
        setTextItems([...textItems]);
      }
    };

    canvas.addEventListener("mousedown", mouseDown);
    canvas.addEventListener("mousemove", mouseMove);
    canvas.addEventListener("mouseup", mouseUp);
    canvas.addEventListener("touchstart", touchStart);
    canvas.addEventListener("touchmove", touchMove, { passive: false });
    canvas.addEventListener("touchend", touchEnd);

    return () => {
      canvas.removeEventListener("mousedown", mouseDown);
      canvas.removeEventListener("mousemove", mouseMove);
      canvas.removeEventListener("mouseup", mouseUp);
      canvas.removeEventListener("touchstart", touchStart);
      canvas.removeEventListener("touchmove", touchMove);
      canvas.removeEventListener("touchend", touchEnd);
    };
  }, [canvasRef, textItems, pageNum, renderPageWithParams, textKey]);




  // const handleContextMenu = useCallback(
  //   (e: MouseEvent) => {
  //     e.preventDefault();
  //     const canvas = canvasRef.current;
  //     if (!canvas) return;

  //     const rect = canvas.getBoundingClientRect();
  //     const canvasX = Math.round(
  //       ((e.clientX - rect.left) * canvas.width) / rect.width
  //     );
  //     const canvasY = Math.round(
  //       ((e.clientY - rect.top) * canvas.height) / rect.height
  //     );

  //     setTextItems((prev) => {
  //       const indexToRemove = prev.findIndex((item) => {
  //         const absX = item.relativeX * canvas.width;
  //         const absY = item.relativeY * canvas.height;
  //         return (
  //           Math.abs(absX - canvasX) < 10 &&
  //           Math.abs(absY - canvasY) < 10 &&
  //           item.page === pageNum
  //         );
  //       });

  //       if (indexToRemove !== -1) {
  //         const updated = [...prev];
  //         console.log(`–£–¥–∞–ª—è–µ–º —Ç–µ–∫—Å—Ç: "${updated[indexToRemove].text}"`);
  //         updated.splice(indexToRemove, 1);
  //         localStorage.setItem(textKey, JSON.stringify(updated));
  //         return updated;
  //       } else {
  //         console.log("–¢–µ–∫—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.");
  //         return prev;
  //       }
  //     });
  //   },
  //   [pageNum, textItems, textKey]
  // );

  // useEffect(() => {
  //   const canvas = canvasRef.current;
  //   if (!canvas) return;

  //   canvas.addEventListener("contextmenu", handleContextMenu);
  //   return () => {
  //     canvas.removeEventListener("contextmenu", handleContextMenu);
  //   };
  // }, [handleContextMenu]);







  export const savePdf = async (
  canvasRef: React.RefObject<HTMLCanvasElement>,
  key: string,
  loadPDFFromDB: (key: string) => Promise<Uint8Array | null>,
  textItems: any[]
) => {
  const pdfBytes = await loadPDFFromDB(key);
  if (!pdfBytes || textItems.length === 0)
    return { success: false, message: "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è" };
  const doc = await PDFDocument.load(pdfBytes);
  doc.registerFontkit(fontkit);

  const fontBytes = await fetch(
    "https://cdn.jsdelivr.net/npm/dejavu-fonts-ttf@2.37/ttf/DejaVuSans.ttf"
  ).then((r) => r.arrayBuffer());
  const font = await doc.embedFont(fontBytes);
  const pages = doc.getPages();

  for (const item of textItems) {
    const page = pages[item.page - 1];
    const { width, height } = page.getSize();
    let pdfX = item.relativeX * width;
    let pdfY = height - item.relativeY * height;

    const maxWidth = 300;
    const lineHeight = 16;
    const words = item.text.split(" ");
    let line = "";

    for (let i = 0; i < words.length; i++) {
      const testLine = line + words[i] + " ";
      const testWidth = font.widthOfTextAtSize(testLine, 16);
      if (testWidth > maxWidth && i > 0) {
        page.drawText(line.trim(), {
          x: pdfX,
          y: pdfY,
          size: 11,
          font,
          color: rgb(0, 0, 0),
        });
        line = words[i] + " ";
        pdfY -= lineHeight;
      } else {
        line = testLine;
      }
    }

    if (line.trim()) {
      page.drawText(line.trim(), {
        x: pdfX,
        y: pdfY,
        size: 11,
        font,
        color: rgb(0, 0, 0),
      });
    }
  }
  const modifiedPdfBytes = await doc.save();
  const blob = new Blob([new Uint8Array(modifiedPdfBytes)], {
    type: "application/pdf",
  });
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = "konspekt.pdf";
  link.click();
  setTimeout(() => URL.revokeObjectURL(link.href), 1500);
  return { success: true, message: "–§–∞–π–ª —Å–æ—Ö—Ä–∞–Ω–µ–Ω" };
};




// export const renderPage = async (
//   pageNum: number,
//   pdfDoc: any,
//   canvasRef: React.RefObject<HTMLCanvasElement>,
//   textItems: any[],
//   scale: number,
//   setPageNum: (n: number) => void,
//   wrapTextFn: typeof wrapText,
//   isRenderingRef: React.MutableRefObject<boolean>,
//   fontValue: number = 16,
//   lineValue: number = 300
// ) => {
//   if (isRenderingRef.current || !pdfDoc) return;
//   isRenderingRef.current = true;

//   const page = await pdfDoc.getPage(pageNum);
//   const viewport = page.getViewport({ scale });
//   const canvas = canvasRef.current;
//   const ctx = canvas?.getContext("2d");
//   if (!canvas || !ctx) {
//     isRenderingRef.current = false;
//     return;
//   }

//   canvas.width = viewport.width;
//   canvas.height = viewport.height;

//   await page.render({ canvasContext: ctx, viewport }).promise;
//   const lineHeight = fontValue + 4;

//   textItems
//     .filter((t) => t.page === pageNum)
//     .forEach((item) => {
//       const absX = item.relativeX * canvas.width;
//       const absY = item.relativeY * canvas.height;

//       const font = item.fontSize ?? fontValue;
//       const line = item.lineWidth ?? lineValue;
//       const lineHeight = font + 4;

//       ctx.font = `${font}px sans-serif`;
//       ctx.fillStyle = "black";
//       ctx.textBaseline = "top";

//       wrapTextFn(ctx, item.text, absX, absY, line, lineHeight);
//     });

//   setPageNum(pageNum);
//   isRenderingRef.current = false;
// };


export const renderPage = async (
  pageNum: number,
  pdfDoc: any,
  canvasRef: React.RefObject<HTMLCanvasElement>,
  textItems: any[],
  scale: number,
  setPageNum: (n: number) => void,
  wrapTextFn: typeof wrapText,
  isRenderingRef: React.MutableRefObject<boolean>,
  fontValue: number = 16,
  lineValue: number = 300
) => {
  if (isRenderingRef.current || !pdfDoc) return;
  isRenderingRef.current = true;

  const page = await pdfDoc.getPage(pageNum);

  const devicePixelRatio = window.devicePixelRatio || 1;
  const viewport = page.getViewport({ scale: scale * devicePixelRatio });

  const canvas = canvasRef.current;
  const ctx = canvas?.getContext("2d");
  if (!canvas || !ctx) {
    isRenderingRef.current = false;
    return;
  }

  // –§–∏–∑–∏—á–µ—Å–∫–∏–π —Ä–∞–∑–º–µ—Ä (–¥–ª—è —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞)
  canvas.width = viewport.width;
  canvas.height = viewport.height;

  // CSS —Ä–∞–∑–º–µ—Ä (–Ω–∞ —ç–∫—Ä–∞–Ω–µ)
  canvas.style.width = `${viewport.width / devicePixelRatio}px`;
  canvas.style.height = `${viewport.height / devicePixelRatio}px`;

  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";

  await page.render({ canvasContext: ctx, viewport }).promise;

  // –†–∏—Å—É–µ–º —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
  textItems
    .filter((t) => t.page === pageNum)
    .forEach((item) => {
      const absX = item.relativeX * canvas.width;
      const absY = item.relativeY * canvas.height;
      const font = item.fontSize ?? fontValue;
      const line = item.lineWidth ?? lineValue;
      const lineHeight = font + 4;

      ctx.font = `${font}px sans-serif`;
      ctx.fillStyle = "black";
      ctx.textBaseline = "top";

      wrapTextFn(ctx, item.text, absX, absY, line, lineHeight);
    });

  setPageNum(pageNum);
  isRenderingRef.current = false;
};





// export function downloadImage(canvas: HTMLCanvasElement, currentPage: number) {
//   if (!canvas) return;
//   const link = document.createElement("a");
//   link.download = `page-${currentPage}.png`;
//   link.href = canvas.toDataURL("image/png");
//   link.click();
// }




// import { useCreateUserWithEmailAndPassword } from "react-firebase-hooks/auth";
// import { auth, firestore } from "../firebase/firebase";
// import {
//   collection,
//   doc,
//   getDocs,
//   query,
//   setDoc,
//   where,
// } from "firebase/firestore";
// import useShowToast from "./useShowToast";
// import useAuthStore from "../store/authStore";
// import { User, SignUpInputs } from "../types/user.dto";
// import Cookies from "js-cookie";


// const useSignUpWithEmailAndPassword = () => {
//   const [createUserWithEmailAndPassword, , loading, error] =
//     useCreateUserWithEmailAndPassword(auth);
//   const showToast = useShowToast();
//   const loginUser = useAuthStore((state) => state.login);

//   const signup = async (inputs: SignUpInputs) => {
//     if (
//       !inputs.email ||
//       !inputs.password ||
//       !inputs.surname ||
//       !inputs.fullName
//     ) {
//       showToast("–û—à–∏–±–∫–∞", "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –ø–æ–ª—è !", "error");
//       return false;
//     }

//     const usersRef = collection(firestore, "users");

//     const q = query(usersRef, where("email", "==", inputs.email));
//     const querySnapshot = await getDocs(q);

//     if (!querySnapshot.empty) {
//       showToast("Error", "Username already exists", "error");
//       return false;
//     }

//     try {
//       const newUser = await createUserWithEmailAndPassword(
//         inputs.email,
//         inputs.password
//       );
//       if (!newUser && error) {
//         showToast("Error", error.message, "error");
//         return false;
//       }
//       if (newUser) {
//         const userDoc: User = {
//           uid: newUser.user.uid,
//           email: inputs.email,
//           surname: inputs.surname || "",
//           username: inputs.email.split("@")[0],
//           fullName: inputs.fullName,
//           role: "guest",
//           profilePicURL: "",
//           accessibleNotes: [],
//           createdAt: Date.now(),
//         };
//         await setDoc(doc(firestore, "users", newUser.user.uid), userDoc);
//         localStorage.setItem("user-info", JSON.stringify(userDoc));
//         Cookies.set("user-info", JSON.stringify(userDoc), {
//           expires: 30, 
//           path: "/", 
//         });
//         loginUser(userDoc);
//         return true;
//       }
//     } catch (error) {
//       if (error instanceof Error) {
//         showToast("Error", error.message, "error");
//       } else {
//         showToast("Error", "An unexpected error occurred", "error");
//       }
//       return false;
//     }
//   };
//   return { loading, error, signup };
// };

// export default useSignUpWithEmailAndPassword;
import { createUserWithEmailAndPassword } from "firebase/auth";
import { auth, firestore } from "../firebase/firebase";
import {
  collection,
  doc,
  getDocs,
  query,
  setDoc,
  where,
} from "firebase/firestore";
import useShowToast from "./useShowToast";
import useAuthStore from "../store/authStore";
import { User, SignUpInputs } from "../types/user.dto";
import Cookies from "js-cookie";
import { useState } from "react";

type UseSignUpHook = {
  signup: (inputs: SignUpInputs) => Promise<boolean>;
  loading: boolean;
  error: Error | null;
};

const useSignUpWithEmailAndPassword = (): UseSignUpHook => {
  const showToast = useShowToast();
  const loginUser = useAuthStore((state) => state.login);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const signup = async (inputs: SignUpInputs): Promise<boolean> => {
    console.log("[SIGNUP] –°—Ç–∞—Ä—Ç —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏", inputs);
    setLoading(true);
    setError(null);

    if (
      !inputs.email ||
      !inputs.password ||
      !inputs.surname ||
      !inputs.fullName
    ) {
      showToast("–û—à–∏–±–∫–∞", "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –ø–æ–ª—è!", "error");
      console.warn("[SIGNUP] –ù–µ –≤—Å–µ –ø–æ–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω—ã");
      setLoading(false);
      return false;
    }

    try {
      const usersRef = collection(firestore, "users");
      const q = query(usersRef, where("email", "==", inputs.email));
      const querySnapshot = await getDocs(q);
      if (!querySnapshot.empty) {
        showToast(
          "–û—à–∏–±–∫–∞",
          "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç",
          "error"
        );
        console.warn("[SIGNUP] Email —É–∂–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω:", inputs.email);
        setLoading(false);
        return false;
      }
    } catch (err) {
      console.error("[SIGNUP] –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ Firestore:", err);
      showToast("–û—à–∏–±–∫–∞", "–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è", "error");
      setError(
        err instanceof Error ? err : new Error("Unknown Firestore error")
      );
      setLoading(false);
      return false;
    }

    let newUserCred;
    try {
      newUserCred = await createUserWithEmailAndPassword(
        auth,
        inputs.email,
        inputs.password
      );
      console.log("[SIGNUP] –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–æ–∑–¥–∞–Ω:", newUserCred.user.uid);
    } catch (err) {
      console.error("[SIGNUP] –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:", err);
      const message =
        err instanceof Error ? err.message : "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –∞–∫–∫–∞—É–Ω—Ç";
      showToast("–û—à–∏–±–∫–∞", message, "error");
      setError(err instanceof Error ? err : new Error("Unknown Auth error"));
      setLoading(false);
      return false;
    }

    if (!auth.currentUser) {
      console.error(
        "[SIGNUP] –ù–µ—Ç –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ—Å–ª–µ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏"
      );
      showToast("–û—à–∏–±–∫–∞", "–ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∞", "error");
      setError(new Error("–ù–µ—Ç –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"));
      setLoading(false);
      return false;
    }

    try {
      const token = await auth.currentUser.getIdToken(true);
      console.log("[SIGNUP] ID —Ç–æ–∫–µ–Ω –ø–æ–ª—É—á–µ–Ω:", !!token);
    } catch (err) {
      console.error("[SIGNUP] –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ç–æ–∫–µ–Ω:", err);
      showToast("–û—à–∏–±–∫–∞", "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ç–æ–∫–µ–Ω –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏", "error");
      setError(
        err instanceof Error ? err : new Error("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–æ–∫–µ–Ω–∞")
      );
      setLoading(false);
      return false;
    }

    const userDoc: User = {
      uid: newUserCred.user.uid,
      email: inputs.email,
      surname: inputs.surname,
      username: inputs.email.split("@")[0],
      fullName: inputs.fullName,
      role: "guest",
      profilePicURL: "",
      accessibleNotes: [],
      createdAt: Date.now(),
    };

    try {
      await setDoc(doc(firestore, "users", newUserCred.user.uid), userDoc);
      console.log("[SIGNUP] –î–æ–∫—É–º–µ–Ω—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —É—Å–ø–µ—à–Ω–æ –∑–∞–ø–∏—Å–∞–Ω");
    } catch (err) {
      console.error(
        "[SIGNUP] –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø–∏—Å–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ Firestore:",
        err
      );
      showToast("–û—à–∏–±–∫–∞", "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –ø—Ä–æ—Ñ–∏–ª—è", "error");
      setError(
        err instanceof Error ? err : new Error("–û—à–∏–±–∫–∞ –∑–∞–ø–∏—Å–∏ –≤ Firestore")
      );
      setLoading(false);
      return false;
    }

    try {
      localStorage.setItem("user-info", JSON.stringify(userDoc));
      Cookies.set("user-info", JSON.stringify(userDoc), {
        expires: 30,
        path: "/",
      });
    } catch (err) {
      console.warn(
        "[SIGNUP] –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø–∏—Å–∞—Ç—å –≤ localStorage –∏–ª–∏ cookies:",
        err
      );
    }

    loginUser(userDoc);
    console.log("[SIGNUP] –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ ‚úÖ");
    setLoading(false);
    return true;
  };

  return { signup, loading, error };
};

export default useSignUpWithEmailAndPassword;



export const renderPage = async (
  pageNum: number,
  pdfDoc: any,
  canvasRef: React.RefObject<HTMLCanvasElement>,
  textItems: any[],
  scale: number,
  setPageNum: (n: number) => void,
  wrapTextFn: typeof wrapText,
  isRenderingRef: React.MutableRefObject<boolean>,
  fontValue: number = 16,
  lineValue: number = 300
) => {
  if (isRenderingRef.current || !pdfDoc) return;
  isRenderingRef.current = true;

  const page = await pdfDoc.getPage(pageNum);
  const devicePixelRatio = window.devicePixelRatio || 1;
  const viewport = page.getViewport({ scale: scale });

  const canvas = canvasRef.current;
  const ctx = canvas?.getContext("2d");
  if (!canvas || !ctx) {
    isRenderingRef.current = false;
    return;
  }

  // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–∏–∑–∏—á–µ—Å–∫–∏–π —Ä–∞–∑–º–µ—Ä —Å —É—á—ë—Ç–æ–º DPR
  canvas.width = viewport.width * devicePixelRatio;
  canvas.height = viewport.height * devicePixelRatio;

  // CSS —Ä–∞–∑–º–µ—Ä ‚Äî –∫–∞–∫ –æ–±—ã—á–Ω–æ
  canvas.style.width = `${viewport.width}px`;
  canvas.style.height = `${viewport.height}px`;

  // –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç
  ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";

  await page.render({ canvasContext: ctx, viewport }).promise;

  // –†–∏—Å—É–µ–º —Ç–µ–∫—Å—Ç
  textItems
    .filter((t) => t.page === pageNum)
    .forEach((item) => {
      const absX = item.relativeX * viewport.width;
      const absY = item.relativeY * viewport.height;
      const font = item.fontSize ?? fontValue;
      const line = item.lineWidth ?? lineValue;
      const lineHeight = font + 4;

      ctx.font = `${font}px sans-serif`;
      ctx.fillStyle = "black";
      ctx.textBaseline = "top";

      wrapTextFn(ctx, item.text, absX, absY, line, lineHeight);
    });

  setPageNum(pageNum);
  isRenderingRef.current = false;
};




useeffect from pdfeditor==================================================

useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas || !pdfDoc) return;

    let draggingItem: TextItem | null = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;

    const getCoords = (clientX: number, clientY: number) => {
      const rect = canvas.getBoundingClientRect();
      return {
        x: ((clientX - rect.left) * canvas.width) / rect.width,
        y: ((clientY - rect.top) * canvas.height) / rect.height,
      };
    };

    const mouseDown = (e: MouseEvent) => {
       if (e.button === 2) return;
      const { x, y } = getCoords(e.clientX, e.clientY);
      for (const item of textItems) {
        if (item.page !== pageNum) continue;

        const ctx = canvas.getContext("2d");
        if (!ctx) continue;

        const metrics = ctx.measureText(item.text);
        const w = metrics.width;
        const h = 20;

        const itemX = item.relativeX * canvas.width;
        const itemY = item.relativeY * canvas.height;

        if (x >= itemX && x <= itemX + w && y >= itemY && y <= itemY + h) {
          draggingItem = item;
          dragOffsetX = x - itemX;
          dragOffsetY = y - itemY;
          if (navigator.vibrate) navigator.vibrate(50);
          break;
        }
      }
    };

    const mouseMove = (e: MouseEvent) => {
      if (!draggingItem) return;

      const rect = canvas.getBoundingClientRect();
      const x = e.clientX;
      const y = e.clientY;

      const isOutside =
        x < rect.left || x > rect.right || y < rect.top || y > rect.bottom;

      if (isOutside) {
        const updated = textItems.filter((item) => item !== draggingItem);
        setTextItems(updated);
        localStorage.setItem(textKey, JSON.stringify(updated));
        console.log(`–£–¥–∞–ª—ë–Ω —ç–ª–µ–º–µ–Ω—Ç –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ: "${draggingItem.text}"`);
        draggingItem = null;
        setTimeout(() => {
          renderPageWithParams(pageNum);
        }, 0);
        return;
      }

      // –æ–±—ã—á–Ω–æ–µ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ
      const canvasX = ((x - rect.left) * canvas.width) / rect.width;
      const canvasY = ((y - rect.top) * canvas.height) / rect.height;

      draggingItem.relativeX = (canvasX - dragOffsetX) / canvas.width;
      draggingItem.relativeY = (canvasY - dragOffsetY) / canvas.height;
    };

    const mouseUp = (e: MouseEvent) => {
      if (!draggingItem) return;

      const rect = canvas.getBoundingClientRect();
      const x = e.clientX;
      const y = e.clientY;

      const isOutside =
        x < rect.left || x > rect.right || y < rect.top || y > rect.bottom;

      let updatedItems = [...textItems];

      if (isOutside) {
        console.log(`–ö—É—Ä—Å–æ—Ä –≤–Ω–µ canvas: ${isOutside}`);
        updatedItems = updatedItems.filter((item) => item !== draggingItem);
        console.log(`–£–¥–∞–ª—ë–Ω —ç–ª–µ–º–µ–Ω—Ç: "${draggingItem.text}"`);
      } else {
        updatedItems = updatedItems.map((item) =>
          item === draggingItem
            ? {
                ...item,
                relativeX: (x - dragOffsetX - rect.left) / rect.width,
                relativeY: (y - dragOffsetY - rect.top) / rect.height,
              }
            : item
        );
      }

      localStorage.setItem(textKey, JSON.stringify(updatedItems));
      setTextItems(updatedItems);
      setTimeout(() => {
        renderPageWithParams(pageNum);
      }, 0);
      draggingItem = null;
    };

    const touchStart = (e: TouchEvent) => {
      const touch = e.touches[0];
      const { x, y } = getCoords(touch.clientX, touch.clientY);
      for (const item of textItems) {
        if (item.page !== pageNum) continue;

        const ctx = canvas.getContext("2d");
        if (!ctx) continue;

        const metrics = ctx.measureText(item.text);
        const w = metrics.width;
        const h = 20;

        const itemX = item.relativeX * canvas.width;
        const itemY = item.relativeY * canvas.height;

        if (x >= itemX && x <= itemX + w && y >= itemY && y <= itemY + h) {
          draggingItem = item;
          dragOffsetX = x - itemX;
          dragOffsetY = y - itemY;
          if (navigator.vibrate) navigator.vibrate(50);
          break;
        }
      }
    };

    const touchMove = (e: TouchEvent) => {
      if (!draggingItem) return;
      e.preventDefault();

      const touch = e.touches[0];
      const x = touch.clientX;
      const y = touch.clientY;

      const rect = canvas.getBoundingClientRect();
      const canvasX = ((x - rect.left) * canvas.width) / rect.width;
      const canvasY = ((y - rect.top) * canvas.height) / rect.height;

      draggingItem.relativeX = (canvasX - dragOffsetX) / canvas.width;
      draggingItem.relativeY = (canvasY - dragOffsetY) / canvas.height;

      const itemX = draggingItem.relativeX * canvas.width;
      const itemY = draggingItem.relativeY * canvas.height;

      const fontSize = draggingItem.fontSize ?? 16;
      const ctx = canvas.getContext("2d");
      ctx!.font = `${fontSize}px sans-serif`;
      const metrics = ctx!.measureText(draggingItem.text);
      const textWidth = metrics.width;
      const textHeight = fontSize * 1.2;

      const leftEdge = itemX;
      const rightEdge = itemX + textWidth;
      const topEdge = itemY;
      const bottomEdge = itemY + textHeight;

      const visibleLeft = Math.max(0, leftEdge);
      const visibleRight = Math.min(canvas.width, rightEdge);
      const visibleWidth = visibleRight - visibleLeft;
      const percentVisible = visibleWidth / textWidth;

      const is90PercentOutside = percentVisible < 0.1;

      if (is90PercentOutside) {
        const updated = textItems.filter((item) => item !== draggingItem);
        localStorage.setItem(textKey, JSON.stringify(updated));
        setTextItems(updated);

        const deletedText = draggingItem.text;
        draggingItem = null;

        setTimeout(() => {
          const stored = localStorage.getItem(textKey);
          if (stored) {
            try {
              const parsed = JSON.parse(stored);
              setTextItems(parsed);
            } catch (err) {
              console.error("–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ localStorage:", err);
            }
          }
          renderPageWithParams(pageNum);
        }, 0);

        console.log(`–£–¥–∞–ª—ë–Ω —ç–ª–µ–º–µ–Ω—Ç –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ >90%: "${deletedText}"`);
        return;
      }
    };

    const touchEnd = (e: TouchEvent) => {
      if (!draggingItem) return;

      const touch = e.changedTouches[0];
      const x = touch.clientX;
      const y = touch.clientY;

      const rect = canvas.getBoundingClientRect();
      const isOutside =
        x < rect.left || x > rect.right || y < rect.top || y > rect.bottom;

      let updatedItems = [...textItems];

      if (isOutside) {
        updatedItems = updatedItems.filter((item) => item !== draggingItem);
        console.log(`–£–¥–∞–ª—ë–Ω —ç–ª–µ–º–µ–Ω—Ç: "${draggingItem.text}"`);
      } else {
        updatedItems = updatedItems.map((item) =>
          item === draggingItem
            ? {
                ...item,
                relativeX: (x - dragOffsetX - rect.left) / rect.width,
                relativeY: (y - dragOffsetY - rect.top) / rect.height,
              }
            : item
        );
      }

      localStorage.setItem(textKey, JSON.stringify(updatedItems));
      setTextItems(updatedItems);
      draggingItem = null;

      // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –∏ —Ä–µ–Ω–¥–µ—Ä
      setTimeout(() => {
        const stored = localStorage.getItem(textKey);
        if (stored) {
          try {
            const parsed = JSON.parse(stored);
            setTextItems(parsed);
          } catch (err) {
            console.error("–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ localStorage:", err);
          }
        }
        renderPageWithParams(pageNum);
      }, 0);
    };

    canvas.addEventListener("mousedown", mouseDown);
    canvas.addEventListener("mousemove", mouseMove);
    canvas.addEventListener("mouseup", mouseUp);
    canvas.addEventListener("touchstart", touchStart);
    canvas.addEventListener("touchmove", touchMove, { passive: false });
    canvas.addEventListener("touchend", touchEnd);
    window.addEventListener("mouseup", mouseUp);
    window.addEventListener("touchend", touchEnd);
    window.addEventListener("touchcancel", touchEnd);
    return () => {
      canvas.removeEventListener("mousedown", mouseDown);
      canvas.removeEventListener("mousemove", mouseMove);
      canvas.removeEventListener("mouseup", mouseUp);
      canvas.removeEventListener("touchstart", touchStart);
      canvas.removeEventListener("touchmove", touchMove);
      canvas.removeEventListener("touchend", touchEnd);
      window.removeEventListener("mouseup", mouseUp);
      window.removeEventListener("touchend", touchEnd);
      window.removeEventListener("touchcancel", touchEnd);
    };
  }, [canvasRef, textItems, pageNum, renderPageWithParams, textKey]);



 "https://cdn.jsdelivr.net/npm/dejavu-fonts-ttf@2.37/ttf/DejaVuSans.ttf"